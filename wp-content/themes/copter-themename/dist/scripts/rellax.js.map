{"version":3,"sources":["../bower_components/rellax/rellax.js"],"names":["root","factory","define","amd","module","exports","Rellax","this","el","options","self","Object","create","prototype","posY","screenY","blocks","pause","loop","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","callback","setTimeout","transformProp","testEl","document","createElement","style","transform","vendors","vendor","undefined","clamp","num","min","max","speed","center","round","keys","forEach","key","elements","querySelectorAll","length","Error","elems","createBlock","dataPercentage","dataset","rellaxPercentage","dataSpeed","rellaxSpeed","pageYOffset","documentElement","scrollTop","body","blockTop","getBoundingClientRect","top","blockHeight","clientHeight","offsetHeight","scrollHeight","percentage","base","updatePosition","cssText","indexOf","index","trimmedStyle","slice","delimiter","replace","height","setPosition","oldY","parentNode","value","Math","update","animate","i","position","translate","destroy","innerHeight","block","push","addEventListener"],"mappings":"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","file":"rellax.js","sourcesContent":["\n// ------------------------------------------\n// Rellax.js - v1.0.0\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.Rellax = factory();\n  }\n}(this, function () {\n  var Rellax = function(el, options){\n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    var posY = 0; // set it to -1 so the animate function gets called at least once\n    var screenY = 0;\n    var blocks = [];\n    var pause = false;\n\n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      function(callback){ setTimeout(callback, 1000 / 60); };\n\n    // check which transform property to use\n    var transformProp = window.transformProp || (function(){\n      var testEl = document.createElement('div');\n      if (testEl.style.transform == null) {\n        var vendors = ['Webkit', 'Moz', 'ms'];\n        for (var vendor in vendors) {\n          if (testEl.style[ vendors[vendor] + 'Transform' ] !== undefined) {\n            return vendors[vendor] + 'Transform';\n          }\n        }\n      }\n      return 'transform';\n    })();\n\n    // limit the given number in the range [min, max]\n    var clamp = function(num, min, max) {\n      return (num <= min) ? min : ((num >= max) ? max : num);\n    };\n\n    // Default Settings\n    self.options = {\n      speed: -2,\n      center: false,\n      round: true,\n      callback: function() {},\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    // If some clown tries to crank speed, limit them to +-10\n    self.options.speed = clamp(self.options.speed, -10, 10);\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    var elements = document.querySelectorAll(el);\n\n    // Now query selector\n    if (elements.length > 0) {\n      self.elems = elements;\n    }\n\n    // The elements don't exist\n    else {\n      throw new Error(\"The elements you're trying to select don't exist.\");\n    }\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    // Bind scroll and resize to animate method\n    var init = function() {\n      screenY = window.innerHeight;\n      setPosition();\n\n      // Get and cache initial position of all elements\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n\n      window.addEventListener('resize', function(){\n        animate();\n      });\n\n      // Start the loop\n      update();\n\n      // The loop does nothing if the scrollPosition did not change\n      // so call animate to make sure every element has their transforms\n      animate();\n    };\n\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n      var dataPercentage = el.dataset.rellaxPercentage;\n      var dataSpeed = el.dataset.rellaxSpeed;\n\n      // initializing at scrollY = 0 (top of browser)\n      // ensures elements are positioned based on HTML layout.\n      //\n      // If the element has the percentage attribute, the posY needs to be\n      // the current scroll position's value, so that the elements are still positioned based on HTML layout\n      var posY = dataPercentage || self.options.center ? (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop) : 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      // apparently parallax equation everyone uses\n      var percentage = dataPercentage ? dataPercentage : (posY - blockTop + screenY) / (blockHeight + screenY);\n      if(self.options.center){ percentage = 0.5; }\n\n      // Optional individual block speed as data attr, otherwise global speed\n      // Check if has percentage attr, and limit speed to 5, else limit it to 10\n      var speed = dataSpeed ? clamp(dataSpeed, -10, 10) : self.options.speed;\n      if (dataPercentage || self.options.center) {\n        speed = clamp(dataSpeed || self.options.speed, -5, 5);\n      }\n\n      var base = updatePosition(percentage, speed);\n\n      // ~~Store non-translate3d transforms~~\n      // Store inline styles and extract transforms\n      var style = el.style.cssText;\n      var transform = '';\n\n      // Check if there's an inline styled transform\n      if (style.indexOf('transform') >= 0) {\n        // Get the index of the transform\n        var index = style.indexOf('transform');\n\n        // Trim the style to the transform point and get the following semi-colon index\n        var trimmedStyle = style.slice(index);\n        var delimiter = trimmedStyle.indexOf(';');\n\n        // Remove \"transform\" string and save the attribute\n        if (delimiter) {\n          transform = \" \" + trimmedStyle.slice(11, delimiter).replace(/\\s/g,'');\n        } else {\n          transform = \" \" + trimmedStyle.slice(11).replace(/\\s/g,'');\n        }\n      }\n\n      return {\n        base: base,\n        top: blockTop,\n        height: blockHeight,\n        speed: speed,\n        style: style,\n        transform: transform\n      };\n    };\n\n    // set scroll position (posY)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n      var oldY = posY;\n\n      if (window.pageYOffset !== undefined) {\n        posY = window.pageYOffset;\n      } else {\n        posY = (document.documentElement || document.body.parentNode || document.body).scrollTop;\n      }\n\n      if (oldY != posY) {\n        // scroll changed, return true\n        return true;\n      }\n\n      // scroll did not change\n      return false;\n    };\n\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPostion and speed\n    // Allow for decimal pixel values\n    var updatePosition = function(percentage, speed) {\n      var value = (speed * (100 * (1 - percentage)));\n      return self.options.round ? Math.round(value * 10) / 10 : value;\n    };\n\n\n    //\n    var update = function() {\n      if (setPosition() && pause === false) {\n        animate();\n      }\n\n      // loop again\n      loop(update);\n    };\n\n    // Transform3d on parallax element\n    var animate = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        var percentage = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        var position = updatePosition(percentage, blocks[i].speed) - blocks[i].base;\n\n        // Move that element\n        // (Set the new translation and append initial inline transforms.)\n        var translate = 'translate3d(0,' + position + 'px,0) ' + blocks[i].transform;\n        self.elems[i].style[transformProp] = translate;\n      }\n      self.options.callback(position);\n    };\n\n\n    self.destroy = function() {\n      for (var i = 0; i < self.elems.length; i++){\n        self.elems[i].style.cssText = blocks[i].style;\n      }\n      pause = true;\n    };\n\n\n    init();\n    return self;\n  };\n  return Rellax;\n}));\n"],"sourceRoot":"assets/scripts/"}